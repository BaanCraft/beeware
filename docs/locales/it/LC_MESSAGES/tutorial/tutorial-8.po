# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, Russell Keith-Magee
# This file is distributed under the same license as the BeeWare package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: BeeWare 0.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-02-13 11:48+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: it\n"
"Language-Team: it <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.14.0\n"

#: ../../tutorial/tutorial-8.rst:3 45030c0e0b9b4ff7845d0519bb418b9a
msgid "Tutorial 8 - Making it Smooooth"
msgstr ""

#: ../../tutorial/tutorial-8.rst:5 66415fac0c9940c1bac5995ad11acff9
msgid "Unless you've got a *really* fast internet connection, you may notice that when you press the button, the GUI for your app locks up for a little bit. This is because the web request we have made is *synchronous*. When our application makes the web request, it waits for the API to return a response before continuing. While it's waiting, it *isn't* allowing the application to redraw - and as a result, the application locks up."
msgstr ""

#: ../../tutorial/tutorial-8.rst:13 b6345b64820d46efb1fb82e43e75484c
msgid "GUI Event Loops"
msgstr ""

#: ../../tutorial/tutorial-8.rst:15 3ad8cf224914421ebe9e0bdc5d3aa57d
msgid "To understand why this happens, we need to dig into the details of how a GUI application works. The specifics vary depending on the platform; but the high level concepts are the same, no matter the platform or GUI environment you're using."
msgstr ""

#: ../../tutorial/tutorial-8.rst:20 c3de2d20c89748f79d2e137fbe02c004
msgid "A GUI app is, fundamentally, a single loop that looks something like::"
msgstr ""

#: ../../tutorial/tutorial-8.rst:26 d5cb2fa861a743daaa7caf123ee4488f
msgid "This loop is called the *Event Loop*. (These aren't actual method names - it's an illustration of what is going on in \"pseudo-code\")."
msgstr ""

#: ../../tutorial/tutorial-8.rst:29 63535685fec04ecf83ac5cb4539f78be
msgid "When you click on a button, or drag a scroll bar, or type a key, you are generating an \"event\". That \"event\" is put onto a queue, and the app will process the queue of events when it next has the opportunity to do so. The user code that is triggered in response to the event is called an *event handler*. These event handlers are invoked as part of the ``process_events()`` call."
msgstr ""

#: ../../tutorial/tutorial-8.rst:35 3847b003cc784724b4cbaca722b71598
msgid "Once an app has processed all the available events, it will ``redraw()`` the GUI. This takes into account any changes that the events have caused to the display of the app, as well as anything else that is going on in the operating system - for example, the windows of another app may obscure or reveal part of our app's window, and our app's redraw will need to reflect the portion of the window that is currently visible."
msgstr ""

#: ../../tutorial/tutorial-8.rst:42 b77aad6a6cd049269b09bcb828b35e91
msgid "The important detail to notice: while an application is processing an event, *it can't redraw*, and *it can't process other events*."
msgstr ""

#: ../../tutorial/tutorial-8.rst:45 803010ba7bae4bfd81bfb620a99956ce
msgid "This means any user logic contained in an event handler needs to complete quickly. Any delay in completing the event handler will be observed by the user as a slowdown (or stop) in GUI updates. If this delay is long enough, your operating system may report this as a problem - the macOS \"beachball\" and Windows \"spinner\" icons are the operating system telling you that your app is taking too long in an event handler."
msgstr ""

#: ../../tutorial/tutorial-8.rst:52 570871fb05d248e197e4b90d1ab51b21
msgid "Simple operations like \"update a label\", or \"recompute the total of the inputs\" are easy to complete quickly. However, there are a lot of operations that can't be completed quickly. If you're performing a complex mathematical calculation, or indexing all the files on a file system, or performing a large network request, you can't \"just do it quickly\" - the operations are inherently slow."
msgstr ""

#: ../../tutorial/tutorial-8.rst:58 b70dbc64d06b46f7a87d7ce5e6ea0e8c
msgid "So - how do we perform long-lived operations in a GUI application?"
msgstr ""

#: ../../tutorial/tutorial-8.rst:61 5b0a74cffea24b388f88b61c1c572e61
msgid "Asynchronous programming"
msgstr ""

#: ../../tutorial/tutorial-8.rst:63 66b8461be5b746c29511d3088e1364c8
msgid "What we need is a way to tell an app in the middle of a long-lived event handler that it is OK to temporarily release control back to the event loop, as long as we can resume where we left off. It's up to the app to determine when this release can occur; but if the app releases control to the event loop regularly, we can have a long-running event handler *and* maintain a responsive UI."
msgstr ""

#: ../../tutorial/tutorial-8.rst:69 bc37a50a910d4e1e96a4c5e0f29a0220
msgid "We can do this by using *asynchronous programming*. Asynchronous programming is a way to describe a program that allows the interpreter to run multiple functions at the same time, sharing resources between all the concurrently running functions."
msgstr ""

#: ../../tutorial/tutorial-8.rst:74 bbdd3af1f4ff4d72afcd2d9e5c85baab
msgid "Asynchronous functions (known as *co-routines*) need to be explicitly declared as being asynchronous. They also need to internally declare when an opportunity exists to change context to another co-routine."
msgstr ""

#: ../../tutorial/tutorial-8.rst:78 6df91fc5abd6487c97d9f736750cf980
msgid "In Python, asynchronous programming is implemented using the ``async`` and ``await`` keywords, and the `asyncio <https://docs.python.org/3/library/asyncio.html>`__ module in the standard library. The ``async`` keyword allows us to declare that a function is an asynchronous co-routine. The ``await`` keyword provides a way to declare when an opportunity exists to change context to another co-routine. The `asyncio <https://docs.python.org/3/library/asyncio.html>`__ module provides some other useful tools and primitives for asynchronous coding."
msgstr ""

#: ../../tutorial/tutorial-8.rst:88 91889f60ef9d4dcba1b6dc964c055102
msgid "Making the tutorial Asynchronous"
msgstr ""

#: ../../tutorial/tutorial-8.rst:90 8d34ca9e91f14516ba287a658f08a5a2
msgid "To make our tutorial asynchronous, modify the ``say_hello()`` event handler so it looks like this::"
msgstr ""

#: ../../tutorial/tutorial-8.rst:104 b6a41a3297de4f45b87ec344febcb386
msgid "There are only 4 changes in this code from the previous version:"
msgstr ""

#: ../../tutorial/tutorial-8.rst:106 5fb8d42d8c324568b07dd2bf569f0697
msgid "The method is defined as ``async def``, rather than just ``def``. This tells Python that the method is an asynchronous co-routine."
msgstr ""

#: ../../tutorial/tutorial-8.rst:109 b661212fcb374fcca59ad9c6c3a49b51
msgid "The client that is created is an asynchronous ``AsyncClient()``, rather than a synchronous ``Client()``. This tells ``httpx`` that it should operate in asynchronous mode, rather than synchronous mode."
msgstr ""

#: ../../tutorial/tutorial-8.rst:113 52544799fad14f7b8b773b86fe4ccd66
msgid "The context manager used to create the client is marked as ``async``. This tells Python that there is an opportunity to release control as the context manager is entered and exited."
msgstr ""

#: ../../tutorial/tutorial-8.rst:117 23d5a0c8ed27411382cf13558fd8f111
msgid "The ``get`` call is made with an ``await`` keyword. This instructs the app that while we are waiting for the response from the network, the app can release control to the event loop."
msgstr ""

#: ../../tutorial/tutorial-8.rst:121 787f36571c6d415286ad0ef8130e4dce
msgid "Toga allows you to use regular methods or asynchronous co-routines as handlers; Toga manages everything behind the scenes to make sure the handler is invoked or awaited as required."
msgstr ""

#: ../../tutorial/tutorial-8.rst:125 f2e1033e747b423ebfec99e334cebfb8
msgid "If you save these changes and re-run the app (either with ``briefcase dev`` in development mode, or by updating and re-running the packaged app), there won't be any obvious changes to the app. However, when you click on the button to trigger the dialog, you may notice a number of subtle improvements:"
msgstr ""

#: ../../tutorial/tutorial-8.rst:130 72cef0dbb11e4cddb75c700cd3998b1d
msgid "The button returns to an \"unclicked\" state, rather than being stuck in a \"clicked\" state."
msgstr ""

#: ../../tutorial/tutorial-8.rst:133 7be0a6674abb47dfa557b712f55f86ff
msgid "The \"beachball\"/\"spinner\" icon won't appear"
msgstr ""

#: ../../tutorial/tutorial-8.rst:135 2ad735d76199485f8927fa71da6d1ac6
msgid "If you move/resize the app window while waiting for the dialog to appear, the window will redraw."
msgstr ""

#: ../../tutorial/tutorial-8.rst:138 391b868708474dc789cdd65519922ee8
msgid "If you try to open an app menu, the menu will appear immediately."
msgstr ""

#: ../../tutorial/tutorial-8.rst:141 7235ad66e90d4676a391185fe9e835af
msgid "Next steps"
msgstr ""

#: ../../tutorial/tutorial-8.rst:143 f0c2837897334035a48b5ee71c501670
msgid "We've now got an application that is slick and responsive, even when it's waiting on a slow API. But how can we make sure that the app keeps working as we continue to develop it further? How do we test our app? Turn to :doc:`Tutorial 9 <tutorial-9>` to find out..."
msgstr ""

